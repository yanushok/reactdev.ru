---
description: Использование вебсокетов вместе с React Query
---

# Использование WebSockets вместе с React Query

Как обрабатывать актуальные данные с использованием веб-сокетов вместе с React Query - один из самых часто задаваемых вопросов в последнее время, поэтому я решил попробовать это, немного поиграться и поделиться своими результатами. Вот о чем этот пост :)

## Что такое Вебсокеты {#what-are-websockets}

Простыми словами, веб-сокеты позволяют отправлять push-сообщения или "живые данные" с сервера на клиент (браузер). Обычно с использованием HTTP клиент отправляет запрос на сервер, указывая, что он хочет получить некоторые данные, сервер отвечает этими данными или ошибкой, а затем соединение закрывается.

Поскольку именно клиент открывает соединения и инициирует запросы, это не оставляет серверу возможности передавать данные клиенту, когда сервер знает, что обновление доступно.

Вот где вступают в действие [веб-сокеты](https://ru.wikipedia.org/wiki/WebSocket).

Как и с любым другим запросом HTTP, браузер инициирует соединение, но указывает, что хочет обновить соединение до веб-сокета. Если сервер соглашается, они переключают протокол. Это соединение не будет завершено, а останется открытым до тех пор, пока одна из сторон не решит его закрыть. Теперь у нас есть полностью функционирующее двустороннее соединение, где обе стороны могут передавать данные.

Главное преимущество этого способа заключается в том, что сервер теперь может отправлять выборочные обновления клиенту. Это может быть очень полезно, если у вас несколько пользователей просматривают одни и те же данные, и один пользователь вносит обновление. Обычно другие клиенты не видят этого обновления до тех пор, пока не начнут активную повторную выборку данных. Веб-сокеты позволяют мгновенно передавать эти обновления в реальном времени.

## Интеграция с React Query {#react-query-integration}

Поскольку React Query в первую очередь является библиотекой управления асинхронным состоянием на стороне клиента, я не буду говорить о том, как настраивать веб-сокеты на сервере. Честно говоря, я никогда этого не делал, и это также зависит от того, какую технологию вы используете в бэкенде.

React Query не имеет встроенного функционала, специально предназначенного для веб-сокетов. Это не означает, что веб-сокеты не поддерживаются или плохо работают с библиотекой. Просто React Query очень агностичен по отношению к тому, как вы получаете свои данные: ему нужен лишь разрешенный или отклоненный `Promise` для работы, остальное зависит от вас.

## Шаг за шагом {#step-by-step}

Общая идея заключается в том, чтобы настроить ваши запросы так, как если бы вы не работали с веб-сокетами. Большинство времени у вас будут обычные конечные точки HTTP для запросов и мутаций сущностей.

```js title="a-standard-query"
const usePosts = () =>
  useQuery({ queryKey: ['posts', 'list'], queryFn: fetchPosts })

const usePost = (id) =>
  useQuery({
    queryKey: ['posts', 'detail', id],
    queryFn: () => fetchPost(id),
  })
```

Кроме того, вы можете настроить эффект `useEffect` для всего приложения, который соединяет вас с вашей конечной точкой веб-сокета. Как это работает, полностью зависит от технологии, которую вы используете. Я видел, как люди подписываются на живые данные от [Hasura](https://github.com/tannerlinsley/react-query/issues/171#issuecomment-649810136). Есть отличная статья о подключении к [Firebase](https://aggelosarvanitakis.medium.com/a-real-time-hook-with-firebase-react-query-f7eb537d5145). В моем примере я просто воспользуюсь встроенным [API веб-сокетов](https://developer.mozilla.org/ru/docs/Web/API/WebSocket) браузера:

```js title="useReactQuerySubscription"
const useReactQuerySubscription = () => {
  React.useEffect(() => {
    const websocket = new WebSocket('wss://echo.websocket.org/')
    websocket.onopen = () => {
      console.log('connected')
    }

    return () => {
      websocket.close()
    }
  }, [])
}
```

### Потребление данных {#consuming-data}

После того как мы настроили соединение, у нас, вероятно, будет какой-то обратный вызов, который будет вызываться, когда поступают данные через веб-сокет. Снова, какие это данные, полностью зависит от того, как вы хотите это настроить. Вдохновленный [этим сообщением](https://github.com/tannerlinsley/react-query/issues/171#issuecomment-649716718) от [Таннера Линсли](https://github.com/tannerlinsley), мне нравится отправлять события с сервера вместо полных объектов данных:

```jsx title="event-based-subscriptions" hl_lines="8-12"
const useReactQuerySubscription = () => {
  const queryClient = useQueryClient()
  React.useEffect(() => {
    const websocket = new WebSocket('wss://echo.websocket.org/')
    websocket.onopen = () => {
      console.log('connected')
    }
    websocket.onmessage = (event) => {
      const data = JSON.parse(event.data)
      const queryKey = [...data.entity, data.id].filter(Boolean)
      queryClient.invalidateQueries({ queryKey })
    }

    return () => {
      websocket.close()
    }
  }, [queryClient])
}
```

Этого вполне достаточно, чтобы обновлять интерфейс списка и деталей, когда поступает событие.

- `{ "entity": ["posts", "list"] }` проинвалидирует список постов
- `{ "entity": ["posts", "detail"], id: 5 }` проинвалидирует один пост
- `{ "entity": ["posts"] }` проинвалидирует все, связанное с постами

[Процесс инвалидации запросов](https://tanstack.com/query/latest/docs/framework/react/guides/query-invalidation) прекрасно взаимодействует с веб-сокетами. Такой подход избегает проблемы избыточной пересылки, потому что, если мы получаем событие для сущности, которая нас в данный момент не интересует, ничего не произойдет. Например, если мы в данный момент находимся на странице Профиля и получаем обновление для Постов, `invalidateQueries` обеспечит перезапрос списка Постов, когда мы следующий раз перейдем на страницу Постов. Однако это не вызовет мгновенный перезапрос, потому что у нас нет активных наблюдателей. Если мы больше никогда не вернемся на эту страницу, полученное обновление было бы совершенно избыточным.

### Частичное обновление данных {#partial-data-updates}

Конечно, если у вас есть большие наборы данных, которые получают небольшие, но частые обновления, вам по-прежнему может потребоваться передавать частичные данные через веб-сокет.

Изменился заголовок поста? Просто отправьте новый заголовок. Изменилось количество лайков - передайте это.

Для этих частичных обновлений вы можете использовать [queryClient.setQueryData](https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientsetquerydata) для прямого обновления кеша запроса, а не только его инвалидации.

Будет немного сложнее, если у вас есть несколько ключей запроса для одних и тех же данных, например, если у вас есть несколько критериев фильтрации в ключе запроса, или если вы хотите обновить список и детальное представление одним и тем же сообщением. [queryClient.setQueriesData](https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientsetqueriesdata) - это относительно новое дополнение к библиотеке, которое также позволит вам решать этот вариант использования:

```jsx title="partial-updates" hl_lines="10-17"
const useReactQuerySubscription = () => {
  const queryClient = useQueryClient()
  React.useEffect(() => {
    const websocket = new WebSocket('wss://echo.websocket.org/')
    websocket.onopen = () => {
      console.log('connected')
    }
    websocket.onmessage = (event) => {
      const data = JSON.parse(event.data)
      queryClient.setQueriesData(data.entity, (oldData) => {
        const update = (entity) =>
          entity.id === data.id
            ? { ...entity, ...data.payload }
            : entity
        return Array.isArray(oldData)
          ? oldData.map(update)
          : update(oldData)
      })
    }

    return () => {
      websocket.close()
    }
  }, [queryClient])
}
```

Для меня это немного динамично, такой подход не управляет добавлением или удалением, да и TypeScript вряд ли будет очень рад. Лично я предпочел бы придерживаться инвалидации запроса.

Тем не менее, вот [пример на codesandbox](https://codesandbox.io/s/react-query-websockets-ep1op), где я обрабатываю оба типа событий: инвалидацию и частичные обновления. _(Примечание: Пользовательский хук немного сложнее, потому что в примере я использую тот же WebSocket для имитации обмена данными с сервером. Не беспокойтесь об этом, если у вас есть реальный сервер)_.

## Увеличение StaleTime {#increasing-staletime}

React Query поставляется с параметром [staleTime по умолчанию](https://tanstack.com/query/latest/docs/framework/react/guides/important-defaults), равным нулю. Это означает, что каждый запрос сразу считается устаревшим, что в свою очередь означает, что он будет повторно запрашиваться, когда новый подписчик монтируется или когда пользователь снова фокусирует окно. Это сделно для того чтобы держать ваши данные настолько актуальными, насколько это необходимо.

Эта цель перекрывается многими функциями WebSockets, которые обновляют ваши данные в реальном времени. Зачем мне вообще повторно запрашивать данные, если я только что вручную их аннулировал, потому что сервер только что сказал мне это сделать с помощью соответствующего сообщения?

Поэтому, если вы все равно обновляете все свои данные через веб-сокеты, рассмотрите возможность установки более высокого значения для `staleTime`. В моем примере я просто использовал значение `Infinity`. Это означает, что данные будут извлечены изначально с использованием `useQuery` и затем всегда будут браться из кеша. Повторный запрос происходит только через явную инвалидацию запроса.

Проще всего этого можно добиться, задав глобальные параметры запроса по умолчанию при создании `QueryClient`:

```jsx title="infinite-stale-times"
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: Infinity,
    },
  },
})
```

<small>:material-information-outline: Источник &mdash; [https://tkdodo.eu/blog/using-web-sockets-with-react-query](https://tkdodo.eu/blog/using-web-sockets-with-react-query)</small>
