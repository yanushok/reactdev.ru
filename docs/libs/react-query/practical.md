---
description: Практические аспекты при использовании React Query
---

# Практический React Query

Когда GraphQL и, в особенности, [Apollo Client](https://www.apollographql.com/docs/react/) стали популярны примерно в 2018 году, возникло много шумихи вокруг возможности полного замещения Redux. А вопрос [Redux уже мертв?](https://dev.to/markerikson/redux---not-dead-yet-1d9k) задавался очень часто.

Я отчетливо помню, что не понимал, в чем здесь суть. Почему библиотека для получения данных должна заменить глобальный менеджер состояния? Что у них общего?

У меня сложилось впечатление, что клиенты GraphQL, такие как Apollo, просто получают данные для вас, подобно тому, что делает, например, [axios](https://github.com/axios/axios) для REST, и что вам все равно нужен будет способ сделать эти данные доступными для вашего приложения.

Однако я сильно ошибался.

## Клиентское состояние против Серверного состояния {#client-state-vs-server-state}

То, что предоставляет Apollo, — это не только возможность описать, какие данные вам нужны, и получить их, но и _кэш_ для этих серверных данных. Это означает, что вы можете использовать один и тот же хук `useQuery` в нескольких компонентах, и он будет запрашивать данные только один раз, а затем возвращать их из кэша.

Это очень похоже на то, для чего мы, и, вероятно, многие другие команды, в основном использовали `redux`: Получать данные с сервера и делать их доступными повсюду.

Таким образом, кажется, что мы всегда относились к этому _серверному состоянию_ как к любому другому _клиентскому состоянию_. За исключением того, что когда речь идет о _серверном состоянии_ (например: список статей, которые вы запрашиваете, подробности о пользователе, которого вы хотите отобразить, и т.д.), ваше приложение им не владеет. Мы только одолжили их, чтобы отобразить на экране пользователю самую последнюю версию. Данные принадлежат серверу.

Для меня это открытие произвело сдвиг парадигмы в понимании данных. Если мы можем использовать кэш для отображения данных, которыми мы не владеем, то на самом деле остается немного реального клиентского состояния, которое также нужно сделать доступным для всего приложения. Это заставило меня понять, почему многие считают, что во многих случаях Apollo может заменить Redux.

## React Query {#react-query}

У меня никогда не было возможности использовать GraphQL. У нас есть существующий REST API, и у нас нет реальных проблем с избыточным запросом данных, всё просто работает и т.д. Очевидно, что у нас нет большого количества проблем, чтобы оправдать переход, особенно учитывая, что для этого также пришлось бы адаптировать бэкэнд, что не так просто.

Однако я всё равно завидовал простоте получения данных на фронтенде, включая обработку состояний загрузки и ошибок. Если бы только было что-то подобное в React для REST API...

И оно есть. [React Query.](https://tanstack.com/query/latest/)

Созданная разработчиком open source ПО [Таннером Линслей](https://github.com/tannerlinsley) в конце 2019 года, React Query берёт лучшие части Apollo и применяет их к REST. Он работает с любой функцией, возвращающей обещание (Promise), и использует стратегию кэширования _stale-while-revalidate_. Библиотека по умолчанию стремится сохранить ваши данные максимально актуальными и одновременно отображать данные пользователю как можно раньше, создавая иногда ощущение мгновенной загрузки, что обеспечивает отличный пользовательский опыт. Кроме того, она очень гибкая и позволяет настраивать различные параметры, когда стандартные настройки не достаточны.

Однако эта статья не является введением в React Query.

Я считаю, что документация отлично объясняет руководства и концепции, есть [видео](https://tanstack.com/query/latest/docs/react/videos) с различных выступлений, которые можно посмотреть, и у Таннера есть [курс по основам React Query](https://learn.tanstack.com/), если вы хотите ознакомиться с библиотекой.

Я хочу сконцентрироваться на практических советах, которые выходят за рамки документации и могут быть полезными, когда вы уже работаете с библиотекой. Это вещи, которые я усвоил за последние несколько месяцев, когда я не только активно использовал библиотеку на работе, но также участвовал в сообществе React Query, отвечая на вопросы в Discord и в обсуждениях на GitHub.

### Настройки по умолчанию {#the-defaults-explained}

Я считаю, что [настройки по умолчанию](https://tanstack.com/query/latest/docs/framework/react/guides/important-defaults) React Query очень хорошо подобраны, но иногда они могут вас удивить, особенно в начале работы с библиотекой.

Прежде всего: React Query не вызывает `queryFn` при каждой повторной отрисовке, даже с параметром `staleTime` по умолчанию, равным нулю. Ваше приложение может повторно отрисовываться по разным причинам в любое время, поэтому выполнение запроса каждый раз было бы неразумным!

!!!abstract ""
    _Всегда пишите код, учитывая повторные отрисовки. Их может быть очень много. Я называю это устойчивостью к повторным отрисовкам._

    — Tanner Linsley

Если вы видите повторный запрос, который не ожидали, скорее всего, это произошло из-за того, что вы только что сфокусировали окно, и React Query выполняет повторный запрос согласно настройке `refetchOnWindowFocus`, что является отличной функцией для продакшена: если пользователь переходит на другую вкладку браузера, а затем возвращается к вашему приложению, будет автоматически выполнен фоновый повторный запрос, и данные на экране обновятся, если что-то изменилось на сервере за это время. Всё это происходит без отображения индикатора загрузки, и ваш компонент не будет повторно отрисовываться, если данные такие же, какие у вас уже есть в кэше.

Во время разработки это вероятно будет происходить чаще, особенно потому, что фокусировка между инструментами разработчика браузера и вашим приложением также вызовет запрос, поэтому будьте внимательны.

!!!danger "Обновление"
    С выходом React Query v5, параметр `refechOnWindowFocus` больше не слушает событие `focus` — он использует исключительно событие `visibilitychange`. Это означает, что в режиме разработки вы получите меньше нежелательных повторных запросов, сохраняя при этом возможность их автоматического запуска в большинстве случаев продакшна. Также это исправляет ряд проблем, как показано [здесь](https://github.com/TanStack/query/pull/4805).

И во-вторых, кажется, есть некоторая путаница между `gcTime` и `staleTime`, позвольте мне попробовать прояснить это:

- `staleTime`: Время до того, как запрос перейдет из состояния свежего в устаревшее. Пока запрос свежий, данные всегда будут считываться только из кэша - сетевой запрос не будет происходить! Если запрос устарел (что по умолчанию происходит мгновенно), вы все равно получите данные из кэша, но фоновый повторный запрос может произойти [при определенных условиях.](https://tanstack.com/query/latest/docs/framework/react/guides/caching)
- `gcTime`: Время до удаления неактивных запросов из кэша. По умолчанию это 5 минут. Запросы переходят в неактивное состояние сразу же, как только не остается ни одного наблюдателя, то есть, когда все компоненты, использующие этот запрос, размонтированы.

Чаще всего вам захочется изменить один из этих параметров, `staleTime`. Мне редко приходилось изменять `gcTime`. В документации также есть хорошее [объяснение на примере](https://tanstack.com/query/latest/docs/framework/react/guides/caching#basic-example).

!!!danger "Обновление"
    Параметр `gcTime` ранее назывался `cacheTime`, но в v5 он был переименован, чтобы лучше отражать то, что он делает.

### Используйте инструменты разработчика React Query {#use-the-react-query-devtools}

Это поможет вам лучше понять состояние запроса. Инструменты разработчика также покажут вам, какие данные в данный момент находятся в кэше, что облегчит процесс отладки. Кроме того, я обнаружил, что полезно замедлить ваше сетевое подключение в инструментах разработчика браузера, если вы хотите лучше распознать фоновые повторные запросы, так как серверы для разработки обычно довольно быстры.

### Рассматривайте ключ запроса как массив зависимостей {#treat-the-query-key-like-a-dependency-array}

Я говорю здесь о массиве зависимостей хука [useEffect](../../reference/react/useEffect.md), который, полагаю, вам знаком.

Почему они похожи?

Потому что React Query будет запускать повторный запрос при изменении ключа запроса. Таким образом, когда мы передаем изменяемый параметр в наш `queryFn`, мы почти всегда хотим получить данные при изменении этого значения. Вместо организации сложных эффектов для ручного запуска повторного запроса мы можем использовать ключ запроса:

```ts title="feature/todos/queries.ts"
type State = 'all' | 'open' | 'done'
type Todo = {
  id: number
  state: State
}
type Todos = ReadonlyArray<Todo>

const fetchTodos = async (state: State): Promise<Todos> => {
  const response = await axios.get(`todos/${state}`)
  return response.data
}

export const useTodosQuery = (state: State) =>
  useQuery({
    queryKey: ['todos', state],
    queryFn: () => fetchTodos(state),
  })
```

Представьте, что наш пользовательский интерфейс отображает список задач вместе с опцией фильтра. У нас есть некоторое локальное состояние, где хранится этот фильтр, и как только пользователь изменяет свой выбор, мы обновляем это локальное состояние, и React Query автоматически запускает повторный запрос для нас, потому что меняется ключ запроса. Таким образом, мы поддерживаем выбор фильтра пользователя _в синхронизации_ с функцией запроса, что очень похоже на то, что представляет собой массив зависимостей для useEffect. Я не думаю, что я когда-либо передавал переменную в `queryFn`, которая не была частью `queryKey`.

#### Новая запись в кэше {#a-new-cache-entry}

Поскольку ключ запроса используется как ключ для кэша, вы получите новую запись в кэше, когда переключитесь с 'all' на 'done', и это приведет к жесткому состоянию загрузки (вероятно, показывая индикатор загрузки) при первом переключении. Это, безусловно, не идеально, поэтому, если возможно, мы можем попробовать предварительно заполнить только что созданную запись в кэше начальными данными ([initialData](https://tanstack.com/query/latest/docs/framework/react/guides/initial-query-data#initial-data-from-cache)). Приведенный выше пример идеально подходит для этого, потому что мы можем выполнить предварительную фильтрацию задач на клиенте:

```ts title="pre-filtering" hl_lines="17-26"
type State = 'all' | 'open' | 'done'
type Todo = {
  id: number
  state: State
}
type Todos = ReadonlyArray<Todo>

const fetchTodos = async (state: State): Promise<Todos> => {
  const response = await axios.get(`todos/${state}`)
  return response.data
}

export const useTodosQuery = (state: State) =>
  useQuery({
    queryKey: ['todos', state],
    queryFn: () => fetchTodos(state),
    initialData: () => {
      const allTodos = queryClient.getQueryData<Todos>([
        'todos',
        'all',
      ])
      const filteredData =
        allTodos?.filter((todo) => todo.state === state) ?? []

      return filteredData.length > 0 ? filteredData : undefined
    },
  })
```

Теперь, каждый раз, когда пользователь переключается между состояниями, если у нас еще нет данных, мы пытаемся показать данные из кэша 'всех задач'. Мы мгновенно можем показать пользователям 'выполненные' задачи, которые у нас есть, и они все равно увидят обновленный список, как только завершится фоновый запрос.

Я считаю, что это отличное улучшение пользовательского опыта за счет всего нескольких строк кода.

### Разделяйте серверное и клиентское состояние {#keep-server-and-client-state-separate}

Это тесно связано с [putting-props-to-use-state](https://tkdodo.eu/blog/putting-props-to-use-state), статьей, которую я написал в ранее: Если вы получаете данные из `useQuery`, старайтесь не помещать эти данные в локальное состояние. Основная причина заключается в том, что вы неявно отказываетесь от всех фоновых обновлений, которые выполняет React Query для вас, потому что "копия" состояния не будет обновляться вместе с ним.

Это нормально, если, например, вы хотите получить некоторые значения по умолчанию для формы и отобразить свою форму, когда у вас есть данные. Фоновые обновления вряд ли принесут что-то новое, и даже если принесут, ваша форма уже инициализирована. Так что если вы делаете это намеренно, убедитесь, что _не_ вызываете лишних фоновых повторных запросов, установив `staleTime`:

```jsx title="initial-form-data"
const App = () => {
  const { data } = useQuery({
    queryKey: ['key'],
    queryFn,
    staleTime: Infinity,
  })

  return data ? <MyForm initialData={data} /> : null
}

const MyForm = ({ initialData }) => {
  const [data, setData] = React.useState(initialData)
  ...
}
```

This concept will be a bit harder to follow through when you display data that you also want to allow the user to edit, but it has many advantages. I have prepared a little codesandbox example.

Этой концепции будет немного сложнее следовать, когда вы отображаете данные, которые вы также хотите разрешить редактировать пользователю, но у нее есть множество преимуществ. Я подготовил небольшой пример кода на codesandbox:

[Sandbox](https://codesandbox.io/p/sandbox/separate-server-and-client-state-rp3jx)

Важная часть этой демонстрации заключается в том, что мы никогда не помещаем значение, которое получаем из React Query, в локальное состояние. Это гарантирует, что мы всегда видим последние данные, потому что нет локальной "копии".

### Опция `enabled` очень мощная {#the-enabled-option-is-very-powerful}

У хука `useQuery` много параметров, которые вы можете передать для настройки его поведения, и опция `enabled` является очень мощной, позволяющей делать много интересных вещей. Вот краткий список вещей, которые мы смогли сделать благодаря этой опции:

- [Зависимые запросы](https://tanstack.com/query/latest/docs/framework/react/guides/dependent-queries)
    Получайте данные в одном запросе и запускайте второй запрос только после успешного получения данных из первого запроса.
- Включение и отключение запросов
    У нас есть один запрос, который регулярно запрашивает данные благодаря `refetchInterval`, но мы можем временно приостановить его, если открыто модальное окно, чтобы избежать обновлений на заднем плане.
- Ожидание пользовательского ввода
    У вас есть некоторые критерии фильтрации в ключе запроса, но отключите их до тех пор, пока пользователь не применит свои фильтры.
- Отключение запроса после ввода пользователем
    например, если у нас есть временное значение черновика, которое должно иметь приоритет над данными с сервера. См. приведенный выше пример.

### Не используйте queryCache в качестве локального хранилища состояния {#dont-use-the-querycache-as-a-local-state-manager}

Если вы вмешиваетесь в queryCache (`queryClient.setQueryData`), это должно происходить только для оптимистичных обновлений или для записи данных, которые вы получили с сервера после мутации. Помните, что каждый фоновый повторный запрос может перезаписать эти данные, поэтому [используйте](../../reference/react/useState.md) [что-нибудь](https://zustand.surge.sh/) [другое](../redux/index.md) для локального состояния.

### Создавайте пользовательские хуки {#create-custom-hooks}

Даже если это всего лишь обёртка для одного вызова `useQuery`, создание пользовательского хука обычно оправдывает себя, потому что:

- Вы можете вынести фактический запрос данных из UI, но разместить его    рядом с вашим вызовом `useQuery`.
- Вы можете хранить все случаи использования одного ключа запроса (и, возможно, определения типов) в одном файле.
- Если вам нужно настроить какие-то параметры или добавить преобразование данных, вы можете сделать это в одном месте.

Вы уже видели пример этого в запросах [к задачам выше.](#treat-the-query-key-like-a-dependency-array)

<small>:material-information-outline: Источник &mdash; [https://tkdodo.eu/blog/practical-react-query](https://tkdodo.eu/blog/practical-react-query)</small>
